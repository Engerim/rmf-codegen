{"version":3,"file":"commercetools-sdk-client.umd.min.js","sources":["../src/allowed-methods.js","../src/validate.js","../src/client.js"],"sourcesContent":["export default [\n  'ACL',\n  'BIND',\n  'CHECKOUT',\n  'CONNECT',\n  'COPY',\n  'DELETE',\n  'GET',\n  'HEAD',\n  'LINK',\n  'LOCK',\n  'M-SEARCH',\n  'MERGE',\n  'MKACTIVITY',\n  'MKCALENDAR',\n  'MKCOL',\n  'MOVE',\n  'NOTIFY',\n  'OPTIONS',\n  'PATCH',\n  'POST',\n  'PROPFIND',\n  'PROPPATCH',\n  'PURGE',\n  'PUT',\n  'REBIND',\n  'REPORT',\n  'SEARCH',\n  'SOURCE',\n  'SUBSCRIBE',\n  'TRACE',\n  'UNBIND',\n  'UNLINK',\n  'UNLOCK',\n  'UNSUBSCRIBE',\n]\n","import METHODS from './allowed-methods'\n\nexport default function validate(\n  funcName: string,\n  request: Object,\n  options: Object = { allowedMethods: METHODS }\n) {\n  if (!request)\n    // eslint-disable-next-line max-len\n    throw new Error(\n      `The \"${funcName}\" function requires a \"Request\" object as an argument. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest`\n    )\n\n  if (typeof request.uri !== 'string')\n    // eslint-disable-next-line max-len\n    throw new Error(\n      `The \"${funcName}\" Request object requires a valid uri. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest`\n    )\n\n  if (!options.allowedMethods.includes(request.method))\n    // eslint-disable-next-line max-len\n    throw new Error(\n      `The \"${funcName}\" Request object requires a valid method. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest`\n    )\n}\n","/* @flow */\nimport qs from 'querystring'\nimport type {\n  Client,\n  ClientOptions,\n  ClientRequest,\n  ClientResult,\n  MiddlewareRequest,\n  MiddlewareResponse,\n  ProcessFn,\n  ProcessOptions,\n  SuccessResult,\n} from 'types/sdk'\nimport validate from './validate'\n\nfunction compose(...funcs: Array<Function>): Function {\n  // eslint-disable-next-line no-param-reassign\n  funcs = funcs.filter((func: Function): boolean => typeof func === 'function')\n\n  if (funcs.length === 1) return funcs[0]\n\n  return funcs.reduce(\n    (a: Function, b: Function): Function => (\n      ...args: Array<Function>\n    ): Array<Function> => a(b(...args))\n  )\n}\n\nexport default function createClient(options: ClientOptions): Client {\n  if (!options) throw new Error('Missing required options')\n\n  if (options.middlewares && !Array.isArray(options.middlewares))\n    throw new Error('Middlewares should be an array')\n\n  if (\n    !options.middlewares ||\n    !Array.isArray(options.middlewares) ||\n    !options.middlewares.length\n  )\n    throw new Error('You need to provide at least one middleware')\n\n  return {\n    /*\n      Given a request object,\n    */\n    execute(request: ClientRequest): Promise<ClientResult> {\n      validate('exec', request)\n\n      return new Promise((resolve: Function, reject: Function) => {\n        const resolver = (rq: MiddlewareRequest, rs: MiddlewareResponse) => {\n          // Note: pick the promise `resolve` and `reject` function from\n          // the response object. This is not necessary the same function\n          // given from the `new Promise` constructor, as middlewares could\n          // override those functions for custom behaviours.\n          if (rs.error) rs.reject(rs.error)\n          else {\n            const resObj: Object = {\n              body: rs.body || {},\n              statusCode: rs.statusCode,\n            }\n            if (rs.headers) resObj.headers = rs.headers\n            if (rs.request) resObj.request = rs.request\n            rs.resolve(resObj)\n          }\n        }\n\n        const dispatch = compose(...options.middlewares)(resolver)\n        dispatch(\n          request,\n          // Initial response shape\n          {\n            resolve,\n            reject,\n            body: undefined,\n            error: undefined,\n          }\n        )\n      })\n    },\n\n    process(\n      request: ClientRequest,\n      fn: ProcessFn,\n      processOpt: ProcessOptions\n    ): Promise<Array<Object>> {\n      validate('process', request, { allowedMethods: ['GET'] })\n\n      if (typeof fn !== 'function')\n        // eslint-disable-next-line max-len\n        throw new Error(\n          'The \"process\" function accepts a \"Function\" as a second argument that returns a Promise. See https://commercetools.github.io/nodejs/sdk/api/sdkClient.html#processrequest-processfn-options'\n        )\n\n      // Set default process options\n      const opt = {\n        total: Number.POSITIVE_INFINITY,\n        accumulate: true,\n        ...processOpt,\n      }\n      return new Promise((resolve: Function, reject: Function) => {\n        const [path, queryString] = request.uri.split('?')\n        const requestQuery = { ...qs.parse(queryString) }\n        const query = {\n          // defaults\n          limit: 20,\n          // merge given query params\n          ...requestQuery,\n        }\n\n        let hasFirstPageBeenProcessed = false\n        let itemsToGet = opt.total\n        const processPage = (lastId?: string, acc?: Array<any> = []) => {\n          // Use the lesser value between limit and itemsToGet in query\n          const limit = query.limit < itemsToGet ? query.limit : itemsToGet\n          const originalQueryString = qs.stringify({ ...query, limit })\n\n          const enhancedQuery = {\n            sort: 'id asc',\n            withTotal: false,\n            ...(lastId ? { where: `id > \"${lastId}\"` } : {}),\n          }\n          const enhancedQueryString = qs.stringify(enhancedQuery)\n          const enhancedRequest = {\n            ...request,\n            uri: `${path}?${enhancedQueryString}&${originalQueryString}`,\n          }\n\n          this.execute(enhancedRequest)\n            .then((payload: SuccessResult) => {\n              const { results, count: resultsLength } = payload.body\n\n              if (!resultsLength && hasFirstPageBeenProcessed) {\n                resolve(acc || [])\n                return\n              }\n\n              Promise.resolve(fn(payload))\n                .then((result: any) => {\n                  hasFirstPageBeenProcessed = true\n                  let accumulated\n                  if (opt.accumulate) accumulated = acc.concat(result || [])\n\n                  itemsToGet -= resultsLength\n                  // If there are no more items to get, it means the total number\n                  // of items in the original request have been fetched so we\n                  // resolve the promise.\n                  // Also, if we get less results in a page then the limit set it\n                  // means that there are no more pages and that we can finally\n                  // resolve the promise.\n                  if (resultsLength < query.limit || !itemsToGet) {\n                    resolve(accumulated || [])\n                    return\n                  }\n\n                  const last = results[resultsLength - 1]\n                  const newLastId = last && last.id\n                  processPage(newLastId, accumulated)\n                })\n                .catch(reject)\n            })\n            .catch(reject)\n        }\n\n        // Start iterating through pages\n        processPage()\n      })\n    },\n  }\n}\n"],"names":["validate","funcName","request","options","allowedMethods","METHODS","Error","uri","includes","method","middlewares","Array","isArray","length","execute","Promise","resolve","reject","funcs","filter","func","reduce","a","b","compose","rq","rs","error","resObj","body","statusCode","headers","dispatch","undefined","process","fn","processOpt","opt","total","Number","POSITIVE_INFINITY","accumulate","split","path","queryString","query","limit","qs","parse","hasFirstPageBeenProcessed","itemsToGet","processPage","lastId","acc","originalQueryString","stringify","enhancedQuery","sort","withTotal","where","enhancedQueryString","enhancedRequest","_this","then","payload","results","resultsLength","count","result","accumulated","concat","last","newLastId","id","catch"],"mappings":"q8CAAe,CACb,MACA,OACA,WACA,UACA,OACA,SACA,MACA,OACA,OACA,OACA,WACA,QACA,aACA,aACA,QACA,OACA,SACA,UACA,QACA,OACA,WACA,YACA,QACA,MACA,SACA,SACA,SACA,SACA,YACA,QACA,SACA,SACA,SACA,eChCa,SAASA,EACtBC,EACAC,OACAC,yDAAkB,CAAEC,eAAgBC,OAE/BH,QAEG,IAAII,qBACAL,2IAGe,iBAAhBC,EAAQK,UAEX,IAAID,qBACAL,4HAGPE,EAAQC,eAAeI,SAASN,EAAQO,cAErC,IAAIH,qBACAL,0ICMC,SAAsBE,OAC9BA,EAAS,MAAM,IAAIG,MAAM,+BAE1BH,EAAQO,cAAgBC,MAAMC,QAAQT,EAAQO,aAChD,MAAM,IAAIJ,MAAM,sCAGfH,EAAQO,cACRC,MAAMC,QAAQT,EAAQO,eACtBP,EAAQO,YAAYG,OAErB,MAAM,IAAIP,MAAM,qDAEX,CAILQ,iBAAQZ,UACNF,EAAS,OAAQE,GAEV,IAAIa,QAAQ,SAACC,EAAmBC,0CAjCzBC,2BAAAA,yBAIG,KAFrBA,EAAQA,EAAMC,OAAO,SAACC,SAA4C,mBAATA,KAE/CP,OAAqBK,EAAM,GAE9BA,EAAMG,OACX,SAACC,EAAaC,UAA0B,kBAElBD,EAAEC,+CA0CQpB,EAAQO,aAAnBc,CAjBA,SAACC,EAAuBC,MAKnCA,EAAGC,MAAOD,EAAGT,OAAOS,EAAGC,WACtB,KACGC,EAAiB,CACrBC,KAAMH,EAAGG,MAAQ,GACjBC,WAAYJ,EAAGI,YAEbJ,EAAGK,UAASH,EAAOG,QAAUL,EAAGK,SAChCL,EAAGxB,UAAS0B,EAAO1B,QAAUwB,EAAGxB,SACpCwB,EAAGV,QAAQY,KAKfI,CACE9B,GAGEc,QAAAA,EACAC,OAAAA,EACAY,UAAMI,EACNN,WAAOM,OAMfC,iBACEhC,EACAiC,EACAC,iBAEApC,EAAS,UAAWE,EAAS,CAAEE,eAAgB,CAAC,SAE9B,mBAAP+B,QAEH,IAAI7B,MACR,mMAIE+B,KACJC,MAAOC,OAAOC,kBACdC,YAAY,GACTL,UAEE,IAAIrB,QAAQ,SAACC,EAAmBC,WACTf,EAAQK,IAAImC,MAAM,QAAvCC,OAAMC,OAEPC,KAEJC,MAAO,SAHiBC,EAAGC,MAAMJ,KAQ/BK,GAA4B,EAC5BC,EAAab,EAAIC,OACD,SAAda,EAAeC,OAAiBC,yDAAmB,GAEjDP,EAAQD,EAAMC,MAAQI,EAAaL,EAAMC,MAAQI,EACjDI,EAAsBP,EAAGQ,eAAeV,GAAOC,MAAAA,KAE/CU,KACJC,KAAM,SACNC,WAAW,GACPN,EAAS,CAAEO,sBAAgBP,QAAc,IAEzCQ,EAAsBb,EAAGQ,UAAUC,GACnCK,OACD3D,GACHK,cAAQoC,cAAQiB,cAAuBN,KAGzCQ,EAAKhD,QAAQ+C,GACVE,KAAK,SAACC,SACqCA,EAAQnC,KAA1CoC,IAAAA,QAAgBC,IAAPC,MAEZD,IAAiBjB,EAKtBlC,QAAQC,QAAQmB,EAAG6B,IAChBD,KAAK,SAACK,OAEDC,KADJpB,GAA4B,EAExBZ,EAAII,aAAY4B,EAAchB,EAAIiB,OAAOF,GAAU,KAEvDlB,GAAcgB,EAOVA,EAAgBrB,EAAMC,QAAUI,EAClClC,EAAQqD,GAAe,aAInBE,EAAON,EAAQC,EAAgB,GAC/BM,EAAYD,GAAQA,EAAKE,GAC/BtB,EAAYqB,EAAWH,MAExBK,MAAMzD,GA1BPD,EAAQqC,GAAO,MA4BlBqB,MAAMzD,GAIXkC"}