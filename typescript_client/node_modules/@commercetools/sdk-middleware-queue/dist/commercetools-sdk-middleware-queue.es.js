function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function createQueueMiddleware() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$concurrency = _ref.concurrency,
      concurrency = _ref$concurrency === void 0 ? 20 : _ref$concurrency;

  var queue = [];
  var runningCount = 0;

  var dequeue = function dequeue(next) {
    // We assume here that this task has been completed
    runningCount -= 1; // Check if there are any other pending tasks and execute them

    if (queue.length && runningCount <= concurrency) {
      var nextTask = queue.shift();
      runningCount += 1;
      next(nextTask.request, nextTask.response);
    }
  };

  return function (next) {
    return function (request, response) {
      // Override response `resolve` and `reject` to know when the request has
      // been completed and therefore trigger a pending task in the queue.
      var patchedResponse = _objectSpread({}, response, {
        resolve: function resolve(data) {
          // Resolve original promise
          response.resolve(data);
          dequeue(next);
        },
        reject: function reject(error) {
          // Reject original promise
          response.reject(error);
          dequeue(next);
        }
      }); // Add task to the queue


      queue.push({
        request: request,
        response: patchedResponse
      }); // If possible, run the task straight away

      if (runningCount < concurrency) {
        var nextTask = queue.shift();
        runningCount += 1;
        next(nextTask.request, nextTask.response);
      }
    };
  };
}

// eslint-disable-next-line import/prefer-default-export

export { createQueueMiddleware };
//# sourceMappingURL=commercetools-sdk-middleware-queue.es.js.map
